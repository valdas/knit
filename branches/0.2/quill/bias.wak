# -*- mode: Awk; -*-  vim: set filetype=awk : 

bias

Given a set of numbers representing frequency counts,
generate numbers biased by those frequencies.

Code
==== 

Uses
----

@uses o math


Top-level Drivers
-----------------

Sample
++++++

Given a list of things, prepare the cdf and memos required to sample from that list.
The _population_ array holds the "_n_"  inputs and _cdf_ and _memo_ are the output. The standard
idiom for running this code is:
    
    collect( pop )   # somehow, collect data
    n=sample(pop,cdf,memo) # set up
    while(repeats--)
	use( memo[pick(cdf,n)] ) # use one item

 function sample(population,cdf,memo,   n,count) { 
     n=length(population)
     for(one in population) 
	 count[population[one]]++
     return sampleCounts(n,count,cdf,memo)
  }

SampleCounts
++++++++++++

Given an arary of thing/frequency pairs, prepare the cdf and memos required to sample from that list.
The standard idiom for running this code is as follows

    collect( counts )   # somehow, collect data
    n=sampleCounts(counts,cdf,memo) # set up
    while(repeats--)
	use( pick(cdf,n) ) # use one item

 function sampleCounts(counts,n,cdf,memo,   one,x,f,i) {
     for(one in counts) {
	 x = (1000*counts[one]/n)+ rand()/100
	 f[++i]= x
	 memo[x] = one
     }
     a2cdf(f,cdf)
     return i
 }

Under the Hood
--------------

a2cdf
+++++

Prepare an array of numbers, prior to picking. 
Internally, this code 
converts an array of numbers into a cdf. From
[http://www.aiaccess.net/English/Glossaries/GlosMod/e_gm_distribution_function.htm
aiaccess.net]: 

+ A _cdf_ (or "cumulative distribtion function") is the
  proportion of the population whose value is less than x.  The _cdf_ of
  a random variable is clearly a monotonously increasing (or more
  precisely, non decreasing) function from 0 to 1.

    
 function a2cdf(a,cdf, sorted,n) {
     n= a2best(a,sorted)
     return sorted2cdf(n,sorted,cdf)
 }

a2best
++++++

If "_a_" is an array of numbers,  then sort them in ascending order.
If _max_ is supplied, return no more than the first _max_ number of values. 

 function a2best(a,best,  max,    sorted,n,i,j) {
                #must     opt     local
     n = asort(a,sorted);
     if (max && n >= max) {
	 for(i = n - max + 1; i<=n; i++)
	     best[++j] = sorted[i];
	 n= max;
     } 
     else 
	 for(i in sorted)
	     best[i]=sorted[i];
     return n;
 }

sorted2cdf
++++++++++

In Awk, we can represent this as an array of  "_n_" symbols stored at
locations 1,2,3..n and a set of increasing probabilities  locations
-1,-2,-3,...-n (where -i is the probability of symbol i).

 function sorted2cdf(n,sorted,cdf,    i,j,sum) {
     sum = cdf[1] = sorted[1];
     for(i=2;i<=n;i++) { 
	 sum += sorted[i];
	 cdf[i] = cdf[i-1] + sorted[i];
     }
     for(i in cdf)  
	 cdf[i] = cdf[i] / sum;
     for(i=1;i<=n;i++)
	 cdf[-1*i] = sorted[i]
     return n
 }

Pick
++++

Return one symbol from a _cdf_, biased by the _cdf_ probabilities. 
If _skew_ is provided, bias the selection towards one end of the
distribtion.

 function pick(cdf,n,  skew,   i) {
               #must   opt     local
     i = pick1(cdf,n,skew)
     return cdf[-1*i]
 }
 function pick1(cdf,n,  skew,u,i) {
     skew = skew ? skew : 1
     u = rand()^skew 
     for(i=n-1;i>=0;i--) {
	 if (u > cdf[i] ) 
	     return i+1;
     }
     return n;
 }

Demos
-----

These demos generate values from the same distribution. We pick at random from a space
of four apples, three  bananas, two carrots and one durian. In the _numericBiasDemo_ 
we already have those counts, while in the _discreateBiasDemo_ we compute them
from a sample. 

 function demoBias() {
     srand(1)
     print "\n---| numericBiasDemo |--------"
     numericBiasDemo("1,3,2,4")
     print "\n---| discreteBiasDemo |--------"
     discreteBiasDemo("apple,banana,carrot,durian,"\
                      "apple,banana,carrot,apple,banana,apple")
 }
 function numericBiasDemo(frequencies,  \
                          n,a,sorted,cdf,max,r,i,count,com) {
     n=split(frequencies,a,",")
     #set up
     a2best(a,sorted)
     sorted2cdf(n,sorted,cdf)
     # generating
     max=r=10000; 
     while(--r)
	 count[pick(cdf,n)]++
     # reporting
     com = "sort -n"
     for(i in count)
	 print i " " count[i] " (" round(100*count[i]/max) "%)" | com
     close(com)
 }
 function discreteBiasDemo(things,       a,cdf,memo,max,r,i,com) {
     split(things,a,",")
     #set up
     n=sample(a,cdf,memo)
     # digression: showing off some internals
     o(cdf,"cdf")          
     o(memo,"memo")
     # generating
     max=r=10000; 
     while(--r)
	 count[memo[pick(cdf,n)]]++ # memo maps numbers to symbols
     # reporting
     com = "sort -n -k 2"
     for(i in count)
	 print i " " count[i] " (" round(100*count[i]/max) "%)" | com
     close(com)     
 }
    
Author
======

Tim Menzies
