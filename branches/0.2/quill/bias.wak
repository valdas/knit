# -*- mode: Awk; -*-  vim: set filetype=awk : 

bias

Given a set of numbers representing frequency counts,
generate numbers biased by those frequencies.

Code
==== 

Uses
----

@uses o math

Example
-------
 
 function demoBias() {
     numericBiasDemo()
     discreteBiasDemo()
 }
 function numericBiasDemo(   n,a,sorted,cdf,max,r,i,count,com) {
     n=split("100,10,1",a,",")
     a2best(a,sorted)
     sorted2cdf(n,sorted,cdf)
     com = "sort -n"
     max=r=1000; 
     while(--r)
	 count[pick(cdf,n)]++
     for(i in count)
	 print i " " count[i] " ( = " round(100*count[i]/max) "%)" | "sort -n"
     close(com)
 }
 function discreteBiasDemo(       a,cdf,memo,max,r,i,com) {
        split("apple,banana,carrot,duck,apple,banana,carrot,apple,banana,apple",a,",")
	o(a,"a")
	n=sample(a,cdf,memo)
	o(cdf,"cdf")
	com = "sort -n"
	max=r=1000; 
	while(--r)
	    count[memo[pick(cdf,n)]]++
	for(i in count)
	    print i " " count[i] " ( = " round(100*count[i]/max) "%)" | "sort -n"
	close(com)
 }

Sample
------

Given a list of things, prepare the cdf and memos required to sample from that list.

 function sample(population,cdf,memo,   f,sum,one,n) {
     n=10 #length(population)
     for(one in population) 
	 count[population[one]]++
     o(count,"count")
     for(one in count) {
	 n = (1000*count[one]/n)+ rand()/100
	 f[one]= n
	 memo[n] = one
     }
     o(memo,"memo")
     return a2cdf(f,cdf)
     
 }

a2cdf
-----

Prepare an array of numbers, prior to picking. 
Internally, this code 
converts an array of numbers into a cdf. From
[http://www.aiaccess.net/English/Glossaries/GlosMod/e_gm_distribution_function.htm
aiaccess.net]: 

+ A _cdf_ (or "cumulative distribtion function") is the
  proportion of the population whose value is less than x.  The _cdf_ of
  a random variable is clearly a monotonously increasing (or more
  precisely, non decreasing) function from 0 to 1.

    
 function a2cdf(a,cdf, sorted,n) {
     n= a2best(a,sorted)
     return sorted2cdf(n,sorted,cdf)
 }

a2best
------

If "_a_" is an array of numbers,  then sort them in ascending order.
If _max_ is supplied, return no more than the first _max_ number of values. 

 function a2best(a,best,  max,    sorted,n,i,j) {
                #must     opt     local
     n = asort(a,sorted);
     if (max && n >= max) {
	 for(i = n - max + 1; i<=n; i++)
	     best[++j] = sorted[i];
	 n= max;
     } 
     else 
	 for(i in sorted)
	     best[i]=sorted[i];
     return n;
 }

sorted2cdf
----------


In Awk, we can represent this as an array of  "_n_" symbols stored at
locations 1,2,3..n and a set of increasing probabilities  locations
-1,-2,-3,...-n (where -i is the probability of symbol i).

 function sorted2cdf(n,sorted,cdf,    i,j,sum) {
     sum = cdf[1] = sorted[1];
     for(i=2;i<=n;i++) { 
	 sum += sorted[i];
	 cdf[i] = cdf[i-1] + sorted[i];
     }
     for(i in cdf)  
	 cdf[i] = cdf[i] / sum;
     for(i=1;i<=n;i++)
	 cdf[-1*i] = sorted[i]
     return n
 }

Pick
----

Return one symbol from a _cdf_, biased by the _cdf_ probabilities. 
If _skew_ is provided, bias the selection towards one end of the
distribtion.

 function pick(cdf,n,  skew,   i) {
               #must   opt     local
     i = pick1(cdf,n,skew)
     return cdf[-1*i]
 }
 function pick1(cdf,n,  skew,u,i) {
     u = bias ? rand()^skew : rand();
     for(i=n-1;i>=0;i--) {
	 if (i==0) 
	     return i
	 else 
	     if (u > cdf[i] ) 
		 return i+1;
     }
     return n;
 }
    
Author
======

Tim Menzies
