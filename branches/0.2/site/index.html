<h1>Welcome to the Art of Awk</h1>

<p>This site is, and is not, about the Awk programming language. 

<p>At first glance, it is a collection of tools and tricks for Awk (more specifcally, GNU Awk a.k.a gawk).

<p>
<img src="``share``/img/easterEgg.jpg" class="rthumb250">But if that is all you see here, then you have missed the art of Awk:
<ul>
	<li>
The art of Awk is to expose core issues by stripping away superflous detail.
<li>
	When you code in Awk, you are thinking  about the problem, 
	not the complexities of the language (because there aren't any:
	no continuations, no inheritance, no pointers, no unions, etc). 
<li>So programming in Awk is a study of the essential essence  of a problem (and not trivial and tedious
implementation details of over-elaborated languages).
</ul>
<p>Awk programmers know that the most powerful tool they have is the one between their ears, and not the compiler on the hard drive.
Talent, not technology, solves problems. And if your pool of talent is thin, then no technology may save you.
<p>
This is not to say that tools are not important. Smart programmers know that they repeat the 
same tasks to solve different problems. And it make sense to build tools to support  those tasks. 
<p>
This site is about those tools, written in Awk (of course!). The question this site tries to answer is
"what tasks are the <em>same</em>, not matter what problem I tackle, not matter
what langauge I use?". The answers are at two levels- the software level and the knowledge level.

<p>
<em>(Aside: at the time of this writing, some of the following tools are not on-line yet. The plan is to
get posted by the end of 2010.)</em>
<p>
At the software level, we note that all code must be (a) written, (b) built, (c) read, (d) tested, and (e) stored.
So this site defines:
<ul>
<li>Writing tools: 
<ul>
<li>A ".wak" file is "<u>w</u>ords and <u>c</u>ode", all mixed up. Based on 
<a href="http://perldoc.perl.org/perlpod.html">Perl's POD files</a>, WAK 
files
let programmers <a href="http://code.google.com/p/knit/source/browse/branches/0.2/quill/bias.wak">mix up comments and code using a simple mark-up language</a> (e.g. paragraphs starting with a space are code, everything
else is a comment.)
<li> We also offer many examples of domain-specific languages, and their use in software development.
</ul>
<li>Building tools: WAK list their depandencies and this site offers automatic tools to package together dependent files.
<li> Reading tools: We support web-browsing of code files. For example, all the pages at this site were auto-generated from WAK files.
<li>Testing tools: After building, the output from a WAK file can be cached. Test suites and regressions suites are now
simple to implement:
just re-run the code and comparing the output to the cache. 
We automate much of this process.
<li>Storing tools: using on-line version control.
</ul>
<p>At the knowledge-level:
<ul>
<li> 
All code runs through a set of states  and some of these states are more preferrable to others.
<li>
This site includes a set of data mining tools that let you nudge a program's behaviour away/towards desired/undesired behavior.
This is useful for controlling a device at runtime or finding errors before the software is released.
</ul>
<p>Sure, some of these tools are available in other IDEs (e.g. EMACS, ECLIPSE). But here's the thing:
<ul>
<li>Some aren't. The idea of routinely applying stochastics and data miners to aid software development is not a widely-used practice.
<li>Finally, many of the current tools are language dependent. In building the tools described here, the discovery was
that these tools are nearly the same <em>no matter what language was used</em>. In fact, all the language dependent stuff
could be isolated in tiny language configuration files.
<li> In many cases, you do not actually have to build these tools. Rather, you only need to mash-up existing services.
For example, the page you are reading actually lives in <a href="http://code.google.com/p/knit/">Google Code</a>. 
So the tools at this site do not need to handle password management, version control, roll-back etc. All that
comes for free, just be using
and existing on-line repository tool.
<li>Also, when you do have to build a tool, they are simple.  Really, really simple. Which is great news! Not only can we avoid overly complex tools,
but it now becomes simpler to modify, customize, and improve the tool support.
</ul>

